<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
function BinarySearchTree(){
    //使用根变量来指向根节点
    this.root = null
    //封装一个节点，里面有key，左子树指针，右子树指针
    function Node(key){
        this.key = key
        this.left = null
        this.right = null
    }
    BinarySearchTree.prototype.insert = function(key){
        let newNode = new Node(key)
        //判断根节点是否为空，空则直接插入
        if(this.root === null){
            this.root = newNode
        }else{
            //不为空则执行递归函数来将新节点插入相应位置
            this.insertNode(this.root, newNode)
        }
    }
    BinarySearchTree.prototype.insertNode = function(root, newNode){
        //当root存在时继续递归
        if(root!==null){
            //当新节点的值大于当前树根节点时
            if(newNode.key > root.key){
                //如果树根节点有右子树时，将右子树当做新树根节点传入
                if(root.right !==null){
                    this.insertNode(root.right, newNode)
                }else{
                    //如果树根节点的右子树不存在时，将新节点存放于右节点上
                    root.right = newNode
                }
            }else{
                //当新节点的值小于当前树根节点时
                if(root.left !==null){
                    //如果树根节点有左子树时，将左子树当做新树根节点传入
                    this.insertNode(root.left, newNode)
                }else{
                    //如果树根节点的左子树不存在时，将新节点存放于左节点上
                    root.left = newNode
                }
            }
        }
    }
    BinarySearchTree.prototype.search = function(key){
        //如果根节点不存在直接返回null
        if(this.root === null){
            return false
        }else{
            //如果存在就遍历整棵树
            let current = this.root
            //current不存在则跳出循环
            while(current !== null){
                //遇到键值匹配则存在此数据
                if(current.key === key) return true
                //当查找的键值小于当前节点的键值则向节点的左边查找否则向右查找
                current = current[key < current.key ? 'left': 'right']
            }
            //如果循环到了树的最深层都没有相应键值则证明不存在这个值
            return false
        }
    }
    BinarySearchTree.prototype.inOrderTraversal = function(){
        let arr = []
        //如果根节点不存在则直接返回
        if(this.root === null) return arr
        //如果根节点存在则递归遍历树
        this.traversalNode('in', this.root, item=>{
            arr.push(item)
        })
        return arr
    }
    BinarySearchTree.prototype.preOrderTraversal = function(){
        let arr = []
        //如果根节点不存在则直接返回
        if(this.root === null) return arr
        //如果根节点存在则递归遍历树
        this.traversalNode('pre', this.root, item=>{
            arr.push(item)
        })
        return arr
    }
    BinarySearchTree.prototype.postOrderTraversal = function(){
        let arr = []
        //如果根节点不存在则直接返回
        if(this.root === null) return arr
        //如果根节点存在则递归遍历树
        this.traversalNode('post', this.root, item=>{
            arr.push(item)
        })
        return arr
    }
    BinarySearchTree.prototype.traversalNode = function(order, root, callback){
        //root存在才继续执行递归
        if(root !== null){
            //中序遍历
            if(order === 'in'){
                //从当前节点的左子树开始继续遍历
                this.traversalNode(order, root.left, callback)
                //已经从左子树处跳回的那个节点对节点的key进行处理
                callback(root.key)
                //从当前节点的右子树开始遍历
                this.traversalNode(order, root.right, callback)
            //前序遍历
            }else if(order === 'pre'){
                //先对当前节点进行操作
                callback(root.key)
                //从当前节点的左子树开始继续递归遍历
                this.traversalNode(order, root.left, callback)
                //从当前节点的右子树开始继续递归遍历
                this.traversalNode(order, root.right, callback)
            //后序遍历
            }else if(order === 'post'){
                //从当前节点的左子树开始继续递归遍历
                this.traversalNode(order, root.left, callback)
                //从当前节点的右子树开始继续递归遍历
                this.traversalNode(order, root.right, callback)
                //对当前节点进行操作
                callback(root.key)
            }
        }
    }
    BinarySearchTree.prototype.min = function(){
        //二叉搜索树特点中整个树最左边的节点是最小值
        let current = this.root
        while(current.left !== null){
            current = current.left
        }
        return current.key
    }
    BinarySearchTree.prototype.max = function(){
        //整个树最右边的节点是最大值
        let current = this.root
        while(current.right !== null){
            current = current.right
        }
        return current.key
    }
        //移除二叉搜索树中的任意节点，此方法难度较高，将几种移除的可能性提前列出
    //  1.移除的节点是叶子节点，即度为0时
    //  2.移除的节点只有一个子节点，即度为1时
    //  3.溢出的节点有两个子节点，即度为2时
    //每种情况下也有多种情形，详细步骤在代码中讨论
    BinarySearchTree.prototype.remove = function(key){
        //初始化需要使用到的变量
        let parrent = null
        let current = this.root
        let isLeftChild = true
        //遍历二叉树直到找到目标节点
        while(current !== null){
            if(key === current.key) break
            //当目标键值小于当前节点键值时向左子树继续查找
            if(key < current.key){
                parrent = current
                current = current.left
                isLeftChild = true
            }else{
                parrent = current
                current = current.right
                isLeftChild = false
            }
        }
        //当current不是空时则找到了目标节点
        if(current !== null){
            //此时目标节点会分成3种情况，进行分别讨论
            //情况一，度为0
            if(current.left === null && current.right === null){
                //当根节点的键值满足时直接删除
                if(current.key === this.root.key){
                    this.root = null
                }else{
                //不是根节点时就是叶子节点，直接删除
                //根据目标节点是父节点的左子树还是右子树来决定清空父节点的哪个指针
                    parrent[isLeftChild ? 'left' : 'right'] = null
                    return current.key
                    }
                    //当目标节点度为2的情况，此处使用前驱来代替目标节点
            }else if(current.left !== null && current.right !== null){
                //当前节点为根节点时，直接将前驱当做根节点
                if(current.key === this.root.key){
                        const preNode = this.findPre(current)
                        preNode.left = current.left
                        preNode.right = current.right
                        this.root = preNode
                    }else{
                        //当前节点不为根节点时
                        //根据目标节点是父节点的左子树还是右子树来决定父节点的哪个指针指向前驱节点
                        const preNode = this.findPre(current)
                        preNode.left = current.left
                        preNode.right = current.right
                        parrent[isLeftChild ? 'left' : 'right'] = preNode
                    }
                    return current.key
                }else{
                    //当目标节点度为1的情况
                    //当current为根节点时直接将根节点指针指向current的子节点
                    if(current.key === this.root.key){
                        this.root = current.left || current.right
                    }else{
                        //current不是根节点时将current的子节点代替current的位置
                        const childNode = current.left || current.right
                        parrent[isLeftChild ? 'left' : 'right'] = childNode
                    }
                    return current.key
                }
            }else{
            //当current为空时则说明没有对应目标节点，返回false
            return false
        }
    }
    //返回一个传入参数的前驱节点的函数
    BinarySearchTree.prototype.findPre = function(root){
        let current = root.left
        let preParrent = root
        //循环直到搜索到根节点的前驱节点
        while(current.right !== null){
            preParrent = current
            current = current.right
        }
        //前驱节点还有左子树时
        if(current.left !== null){
            //如果是根节点的左子树则将前驱节点的左子树赋值给根节点的左子树
            //如果不是则用前驱节点的左子树赋值给前驱节点的父节点的右子树
            preParrent[current === root.left ? 'left' : 'right'] = current.left
        }else{
        //没有左子树则直接置空前驱节点的原位置
            //如果是根节点的左子树则清空左子树
            //如果不是则清空父节点的右子树
            preParrent[current === root.left ? 'left' : 'right'] = null
        }
        //返回前驱节点
        return current
    }
}
var bst = new BinarySearchTree()
bst.insert( 11)
bst.insert(17)
bst.insert(12)
bst.insert(1)
bst.insert(7)
bst.insert(9)
bst.insert(18)
bst.insert(6)
bst.insert(13)
bst.insert(16)
bst.insert(3)
bst.insert(25)
console.log(bst.remove(11), bst.inOrderTraversal())
    </script>
</body>
</html>